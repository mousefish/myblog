---
title: 'The Rust Learning Notes'
date: '2022-08-15'
tags: ['rust']
draft: false
summary: 'Learning the Rust and put some notes here for furture reference'
---

## 1. variables

```rust
const CONST_VALUE: u32 = 10;
let number: f32 = 10;
```

- number is the variable name, f32 is type, 10 is value.
- All variable default is immutable, for safty, concurrency and speed.
- Use let `mut` number: f32 = 10; to change number to a mutable value that can be changed later.
- const defines const type, const type is immutable forever, and it must indicates the type.

## 2. function

```rust
fun do_stuff(a: f32, b: f32) -> f32 {
    {
        let x = 2;
        println!("{}", x);
    }
    // x is not available outside the scope
    a*b
}
```

- a:f32, b:f32 define the function arguments, ->f32 indicate the return type.
- a*b is the return value, same as `return a*b;`, remember if don't use `return`keyward, don't use`;` in the end.
- variable only available in the scope, x is assigned inside {} scope, it will drop automatically when leaving the {}.

## 3. shadowing

```rust
fn main() {
    let x = 5;
    let x = x + 6;
    {
        let x = x * 7; //x is 77
    }
    //x here is 11
}
```

- declare a new variable with the same name as previous is first variable shadowed by the second.
- compile only sees the latest one until it out of scope

## 4. Data Types

### Integer Type:

`u8, u16, u32, u64, u128, usize, i8, i16, i32, i64, i128, isize, 0xff, 0b1111_0000, b'A'`

- u is unsigned value, i is signed, u/isize is the value depends on 32bit or 64bit system
- type suffix is allowed like `20u8`
- default integer type is i32
- 0xff is hex, 0b is binary, b is byte
- can use \_ to make large number easy read like `1_000_000`

### Float type

`f32, f64`

- default is f64

### Bollean Type

`bool`

### Char Type

`char`

- char type is four bytes in size in rust

### Tuple type

```rust
    let tup: (i32, f32) = (3, 8.8);
    let first_elemnt = tup.0;
    let (first, second) = tup;
```

- tuple element can be different type
- access the tuple value by use .index like tup.0 above
- (first, second) destructures the tup and get the value

### Array Type

```rust
let array: [u32, 5] = [1,2,3,4,5];
let first = array[0];
let inital_array = [0; 5] // equal to [0, 0, 0, 0, 0]
```

- array must have same type and fixed length
- [u32, 5], first one defines type, second is length
- [0; 5] means inital array value to all 0 and array length is 5
- use array_name[index] to access the array member

## 5. Control Flow

### if..else

```rust
if x<0 {5} else if x<6 {6} else {7}
```

- if condition doesn't need `()` after if like `if(x<0)` in rust
- if can assign value like `let value = if x<0 {5}`, value is 5 here

### loops :

```rust
let count  = 0;
 'first_loop': loop{
    let value = loop {
        if count == 2
        {
            break count;
        }
        count += 1;
        if count == 3
        {
            break 'first_loop'
        }
    }
    count += 1;
 }
```

- `first_loop` is the defined name to distinguish different loops
- `break count` can quit the loop and return the value of count
- `break first_loop` can quit the loop named `first_loop`

### while

```rust
while number !== 0 {
    number -= 1
}
```

### for

```rust
let array = [1,2,3,4,5]
for element in array {
    println!("the value is : {element}")
}
```

### 6. Ownership

```rust
fn main(){
    let s1 = String::from("Owner");
    let s2 = s1;
    //s1 is not available anymore because s1 is move ownership to s2 for the string
    let x1 = 5;
    let x2 = x1;
    //here we can access both x1 and x2, because x1 is on stack, and it int32 applys copy trait to copy the value to x2
}
```

- Rust use ownership to manage memory, there is only one owner for the value in rust, once the value move out of scope, it calls drop to free the memory
- if you want to keep s2 and s1 above both available, use `s2 = s1.clone()` to copy the value, copy trait is not allowed for the value implement the Drop trait

```rust
fn main(){
    let s1 = String::from("Owner");
    get_length(&s1);
}

fn get_length(s: &String) -> usize {
    s.len()
}
```

- we use & to borrow the reference to the string and the ownership now still belong to s1, so when function returns, the s1 is not dropped
- only one mutable browwer can exist during the same scope, but we allowed multiple immutable references.

### 7. Slice

```rust
let s = String::from("Hello World");
let hello = &s[0..5];

let a = [0,1,2,3,4,5];
let a1_2 = &a[1, 3];
assert_eq!(a1_2, &[1,2]);
```

- slice return a reference with pointer and length to the original data
- above `&s[..5]` give the same result, and `s[..]`returs "Hello World"
