---
title: '学习Rust语言笔记'
date: '2022-08-15'
tags: ['rust']
draft: false
summary: '记录了学习Rust的一些核心知识要点方便未来查看'
---

## 1. 变量

```rust
const CONST_VALUE: u32 = 10;
let number: f32 = 10;
```

- number 是变量名, f32 是类型, 10 是赋予变量的值.
- 所有的变量默认是不可变的, 就是说赋值后无法更改， 这是为了多线程的安全性和提供更快的读取速度.
- 如果要更改变量, 可以使用 let `mut` number: f32 = 10; 增加'mut'关键字来表示此变量可以改变.
- const 定义 const 变量，const 必须要定义类型，并且赋值后无法更改

## 2. 函数

```rust
fun do_stuff(a: f32, b: f32) -> f32 {
    {
        let x = 2;
        println!("{}", x);
    }
    // x在离开{}域后这里将无法使用
    a*b
}
```

- a:f32, b:f32 是函数的参数, ->f32 为函数的返回值.
- a*b 是为返回数值, 和 `return a*b;`有相同的作用, 不使用 return 和 ; 只是为了更方便使用, 本质和使用 return 无任何区别, 需要注意的是如果不用 return,也不能用;
- 变量有自己的固定域， 通常包含在{}里, 如果离开{}范围后，变量会自动销毁无法继续使用. 比如这里 x 是在独立的{}中声名的,离开{}后 x 无法继续使用.

## 3. 阴影

```rust
fn main() {
    let x = 5;
    let x = x + 6;
    {
        let x = x * 7; //x 为 77
    }
    //x 为 11
}
```

- 声明前一个变量名同样名字的变量叫阴影覆盖
- 编译器只在意最后一个变量直到变量离开自己的域

## 4. 类型

### 整数类型:

`u8, u16, u32, u64, u128, usize, i8, i16, i32, i64, i128, isize, 0xff, 0b1111_0000, b'A'`

- u 是无符号整数, i 是有符号整数, u/isize 是类型基于系统，如 32bit 系统和 64bit 系统会返回不同的整数类型
- 可以用`20u8`来指定 20 为 u8 类型
- i32 为默认整数类型
- 0xff 是十六进制, 0b 代表二进制, b 代表字符
- 可以使用 \_ 来让大的整数更容易读， 比如 `1_000_000`

### 浮点类型

`f32, f64`

- f64 为默认类型

### Bollean 类型

`bool`

### Char 类型

`char`

- char 类型为 4 个字节

### Tuple 类型

```rust
    let tup: (i32, f32) = (3, 8.8);
    let first_elemnt = tup.0;
    let (first, second) = tup;
```

- tuple 中的每个成员可以为不同的类型
- 可以使用 .索引 来读取 tuple 中的成员，比如上述第一个成员使用 tup.0 读取
- (first, second)将 tuple 函数中的成员分别赋值给 first, second

### 数组类型

```rust
let array: [u32, 5] = [1,2,3,4,5];
let first = array[0];
let inital_array = [0; 5] // 等于 [0, 0, 0, 0, 0]
```

- 数组中所有成员必须为相同类型，并且数组长度是固定不变的
- [u32, 5], 第一个 u32 定义了数组的类型， 第二个 5 代表数组长度
- [0; 5] 是将一个长度为 5 的数组所有成员初始化为 0
- 使用数组名[索引]来访问数组成员

## 5. 控制流程

### if..else

```rust
if x<0 {5} else if x<6 {6} else {7}
```

- 在 rust 中 if 后面不需要使用`()`如`if(x<0)`
- 可以将 if 的结果给别的变量赋值，比如 `let value = if x<0 {5}`, 这里 value 的值为 5

### loops :

```rust
let count  = 0;
 'first_loop': loop{
    let value = loop {
        if count == 2
        {
            break count;
        }
        count += 1;
        if count == 3
        {
            break 'first_loop'
        }
    }
    count += 1;
 }
```

- `first_loop` 是给与第一个 loop 的名字用于区别其他的 loop
- `break count` break 用于结束 loop， break 后跟随 count 表示同时将 count 的数值返回
- `break first_loop` 这里如果跟着我们提前给与的 loop 名字表示我们要结束这个名字的 loop

### while

```rust
while number !== 0 {
    number -= 1
}
```

### for

```rust
let array = [1,2,3,4,5]
for element in array {
    println!("the value is : {element}")
}
```

### 6. 所有权

```rust
fn main(){
    let s1 = String::from("Owner");
    let s2 = s1;
    //这里s1已经失效，读取会错误， 因为s1已经将所有权传递给了s2
    let x1 = 5;
    let x2 = x1;
    //这里x1和x2都仍然有效，因为x1在内存堆上，非常容易进行复制，而且i32这类基本的已知大小的类型已经采用了copy trait来实现内容的复制
}
```

- Rust 使用所有权来管理内存。在同样的域中一个内存空前只允许有一个拥有者，当拥有者离开域，会通过调用 drop 函数来释放内存
- 如果希望 s2 和 s1 拥有一样的内存数据，可以使用 `s2 = s1.clone()` 来复制 s1 的内存内容到 s2, copy trait 不允许在已采用 drop trait 的目标使用。

```rust
fn main(){
    let s1 = String::from("Owner");
    get_length(&s1);
}

fn get_length(s: &String) -> usize {
    s.len()
}
```

- 这里我没通过&符号来借用 s1 的所有权，当借用离开自己的域时，不会调用 drop 来释放内存，因为所有权仍然属于 s1
- 在同一个域中只能借用一次`mute`可改变的所有权，但是允许借用多次不可改变的所有权，因为 rust 无法预防其他借用在读取同一个内存空间的时候会被其他的借用更改数据

### 7. Slice

```rust
let s = String::from("Hello World");
let hello = &s[0..5];

let a = [0,1,2,3,4,5];
let a1_2 = &a[1, 3];
assert_eq!(a1_2, &[1,2]);
```

- slice 返回一个指向原数据位置的指针以及需要的长度
- 以上如果改成 `&s[..5]` 将得到同样的结果, `s[..]`将会返回整个 "Hello World"

### 8. 结构

```rust
#[derive(Debug)]
struct Shape {
   isRound : bool,
   Box: i32
}

impl Shape{
   fn new() -> Self{
     Self{
         isRound: false,
         Box: 32,
       }
  }

   fn some_function() {} // 用Shape::some_function来调用这个函数, 没有&self无法使用shape.some_function来调用
   fn another_function(&self) {} // 第一个参数必须为&self来允许shape.another_function的方式调用函数
}

let s = Shape::new();
```

- #[derive(Debug)] 用于使用 `println!("{:?}", shape)` 或者 `println!("{:#?}", shape)` 来进行 shape 结构的打印调试
- 也可以使用 `dbg!` 在不同的代码行中插入，比如 `dbg!(&shape)` 来打印 shape 进行调试

### 9. Enum

```rust
enum TestObject {
   Empty,
   Square(u32, u32),
   Round(f32),
   Position {x: f32, y: f32}
}

impl TestObject {
   fn display(&self) {}
}

fn get_result(testobj: TestObject) {
    match testobj {
        TestObject::Square(x,y) => println!("square width {}, height {}", x, y),
        TestObject::Round(x) => println!("round radius {}", x),
        TestObject::Position{x, y}=> println!("position is x: {} y: {}", x, y),
        _ => println!("Empty"),
    }
}

let shape = TestObject::Square(6, 5);
let pos = TestObject::Position{x: 3.0, y: 3.0};

get_result(shape);

if let TestObject::Square(x, y) = shape {
	println!("it match the result square width {} height {}", x, y);
}
else
{
	println!("it doesn't match")
}
```

- Enum 可以使用不同形式的值在其中，比如 `Square(u32, u32)`
- Enum 可以像结构一样加载函数
- 使用`_`来表示是在上述条件都不满足的情况下，其余任何情况都调用以下方法，并且我们并不需要对应的值， 也可以使用 `other =>` 代替如果需要使用相应的值
- 使用 `if let` 来判断是否和 enum 的某一个格式一致，并读取其中数值

```rust
enum Option<T> {
  Some(T),
  None,
}
let mut x: Option<i32> = None;
x = Some(5);
x.is_some(); //true
x.is_none(); //false
for i in x {
 println!("{}", i); //显示 5
}

enum Result<T, E> {
	Ok(T),
    Err(E),
}
```

- Rust 不允许使用 Null 这个值, 所以当必须要使用 Null 来表示某个空值时, 可以使用 Option 来代替 Null, Option 由于是 enum，所以可以为 None, 也可以为 Some(value)
